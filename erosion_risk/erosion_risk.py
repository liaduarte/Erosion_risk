# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ErosionRisk
                                 A QGIS plugin
 This plugin estimated the soil erosion risk based on different RUSLE methodologies.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-16
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Duarte et al
        email                : liaduarte@fc.up.pt
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import *
from qgis.gui import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .erosion_risk_dialog import ErosionRiskDialog
import os.path
SYS_DIR  = "C:/OSGeo4W64/apps"
QGIS_DIR = os.path.join(SYS_DIR, 'qgis')


class ErosionRisk:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ErosionRisk_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Erosion Risk')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ErosionRisk', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/erosion_risk/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Erosion Risk'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Erosion Risk'),
                action)
            self.iface.removeToolBarIcon(action)

    def fillOutR(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.dlg.lineEdit_22.setText(filename)

    def fillOutK(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.dlg.lineEdit_22.setText(filename)

    def fillOutLS(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.dlg.lineEdit_22.setText(filename)

    def fillOutRUSLE1(self):
        filename, filter_string = QFileDialog.getSaveFileName(self.dlg, "Select output file ", "", '*.tif')
        self.dlg.lineEdit_22.setText(filename)


    def fillInSoil(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select Soil map ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.dlg.comboBox_3.addItem(filename)

    def fillInDEM(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select DEM map ", "", '*.tif')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        # add the raster
        vlayer = QgsRasterLayer(path, basename)
        self.dlg.comboBox_3.addItem(filename)

    def fillStudyZone(self):
        filename, filter_string = QFileDialog.getOpenFileName(self.dlg, "Select Study zone ", "", '*.shp')
        fileCI = str(filename)

        fileInfo = QFileInfo(fileCI)
        path = fileInfo.filePath()
        basename = fileInfo.baseName()

        vlayer = QgsVectorLayer(path, basename)
        self.dlg.comboBox_7.addItem(filename)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ErosionRiskDialog()

            self.method_R = self.dlg.comboBox_10.addItems(['Wischemeier and Smith, 1978','Joint Research Center'])
            self.method_K = self.dlg.comboBox_3.addItems(['Pimenta, 1998','Joint Research Center'])
            self.method_LS = self.dlg.comboBox_4.addItems(['Wischemeier and Smith, 1978', 'Mitasova, 1996', 'Moore and Wilson, 1992', 'McCool, 1987'])

            self.dlg.pushButton_2.clicked.connect(self.fillOutR)
            self.dlg.pushButton_22.clicked.connect(self.fillInSoil)
            self.dlg.pushButton_23.clicked.connect(self.fillOutK)
            self.dlg.pushButton_27.clicked.connect(self.fillInDEM)
            self.dlg.pushButton_28.clicked.connect(self.fillOutLS)
            self.dlg.pushButton_10.clicked.connect(self.fillOutRUSLE1)
            self.dlg.pushButton_8.clicked.connect(self.conclude)
            self.dlg.pushButton_26.clicked.connect(self.fillStudyZone)

            # Get all loaded layers in the interface
            layers = QgsProject.instance().mapLayers()
            # layers = self.iface.legendInterface().layers()

            # Create an empty list which we can populate
            list_names_layers = []
            # list of layer names using list comprehension
            l = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
            # dictionary with key = layer name and value = layer object
            layers_list = {}
            for l in QgsProject.instance().mapLayers().values():
                layers_list[l.name()] = l
            for name, value in layers_list.items():
                list_names_layers.append(name)

            # self.dlg.comboBox.addItems(list_names_layers)
            # self.dlg.comboBox_2.addItems(list_names_layers)
            # self.dlg.comboBox_3.addItems(list_names_layers)
            # self.dlg.comboBox_4.addItems(list_names_layers)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

    # BUTTON ADD AND REMOVE CLASSES K map
    def actionAdd(self):
        n = self.tableWidget.rowCount()
        self.tableWidget.insertRow(n)
        n = self.tableWidget.rowCount()
        return True

    def actionAdd_k(self):
        n = self.tableWidget_k.rowCount()
        self.tableWidget_k.insertRow(n)
        n = self.tableWidget_k.rowCount()
        return True

    def actionRemove(self):
        n = self.tableWidget.rowCount()
        for i in range(1, n):
            self.tableWidget.removeRow(n - 1)
        n = self.tableWidget.rowCount()
        return True

    def actionRemove_k(self):
        n = self.tableWidget_k.rowCount()
        for i in range(1, n):
            self.tableWidget_k.removeRow(n - 1)
        n = self.tableWidget_k.rowCount()
        return True

    # PDF CONNECTION
    def pdf(self):
        ## access to pdf files
        import subprocess
        pdf = os.path.join(QGIS_DIR, "python/plugins/erosion_risk/Table K Factor.pdf")
        subprocess.Popen([pdf], shell=True)

    def attributeTable(self):
        inputLayer = self.inputLayerCombo_soil.currentText()
        # layer information
        layer = QgsVectorLayer(inputLayer, 'inputLayer', "ogr")
        # attribute
        Elevation = self.lineAttrib.currentText()
        fields = layer.fields()
        field_names = [field.name() for field in fields]
        n = len(field_names)
        lista_attrib = []
        for i in range(0, n):
            f = field_names[i]
            if f == str(Elevation):
                number = i
                for feat in layer.getFeatures():
                    attrb = feat.attributes()
                    attribute_read = attrb[number]  # reads the attribute one by one
                    lista_attrib = lista_attrib + [str(attribute_read)]
        # list of description on attribute table of shapefile
        lista_attributes = lista_attrib
        len_attb = len(lista_attributes)

        # delete duplicate names
        lista_att_dupl = []
        [lista_att_dupl.append(i) for i in lista_attributes if not i in lista_att_dupl]

        # if the user select table 1
        if self.checkBox1.isChecked():
            # save the description of shapefile in tool table and delete all the other information, such as indexes and other descriptions
            numberRows = int(self.tableWidget.rowCount())
            self.tableWidget.clearContents()

            for j in range(0, len(lista_att_dupl)):
                self.tableWidget.setItem(j, 0, QTableWidgetItem(lista_att_dupl[j]))

            # remove the lines with no values
            for a in range(0, numberRows):
                if self.tableWidget.item(a, 0) == None:
                    self.actionRemove()

        # if the user select table 2
        if self.checkBox2.isChecked():
            # save the description of shapefile in tool table and delete all the other information, such as indexes and other descriptions
            numberRows = int(self.tableWidget_k.rowCount())
            self.tableWidget_k.clearContents()

            for j in range(0, len(lista_att_dupl)):
                self.tableWidget_k.setItem(j, 0, QTableWidgetItem(lista_att_dupl[j]))

            # remove the lines with no values
            for a in range(0, numberRows):
                if self.tableWidget_k.item(a, 0) == None:
                    self.actionRemove_k()

                    # if the user doesn't select any table
        else:
            QMessageBox.warning(self, "RUSLE",
                                "Please select a table.",
                                QMessageBox.Ok);

    def conclude(self):

        study_zone = self.dlg.comboBox_13.currentText()

        self.outputR = self.dlg.lineEdit.text()
        self.outputK = self.dlg.lineEdit_10.text()
        self.outputLS = self.dlg.lineEdit_12.text()
        self.outputP = self.dlg.lineEdit_2.text()

        inputDEM_LS = self.dlg.comboBox_14.currentText()
        # slope_length
        slope_length = Processing.runAlgorithm("saga:slopelength", {'DEM': str(inputDEM_LS),
                                                     'LENGTH': QgsProcessingUtils.generateTempFilename(
                                                         'slope_length.sdat')})
        self.slopelength = slope_length['LENGTH']
        # slope degree
        slope_degree = Processing.runAlgorithm("gdal:slope",
                                {'INPUT': str(inputDEM_LS), 'BAND': 1,
                                 'SCALE': 1, 'AS_PERCENT': False, 'COMPUTE_EDGES': False, 'ZEVENBERGEN': False,
                                 'OPTIONS': '', 'EXTRA': '',
                                 'OUTPUT': QgsProcessingUtils.generateTempFilename(
                                                         'slope_degree.tif')})
        self.slopedegree = slope_degree['OUTPUT']
        # slope percentage
        slope_perc = Processing.runAlgorithm("gdal:slope",
                                {'INPUT': str(inputDEM_LS), 'BAND': 1,
                                 'SCALE': 1, 'AS_PERCENT': True, 'COMPUTE_EDGES': False, 'ZEVENBERGEN': False,
                                 'OPTIONS': '',
                                 'EXTRA': '',
                                 'OUTPUT': QgsProcessingUtils.generateTempFilename(
                                                         'slope_percentage.tif')})
        self.slopeperc = slope_perc['OUTPUT']

        # create R map
        # unidades (FALTA)
        # clip the layers
        clip_R = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
            'INPUT': str(input_Erosivity),
            'MASK': study_zone,
            'SOURCE_CRS': None,
            'TARGET_CRS': None, 'NODATA': None,
            'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
            'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
            'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
            'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_R.tif')})
        self.out_R = clip_R['OUTPUT']

        # R from SniAMB
        if self.method_R.currentText()=='Wischemeier and Smith, 1978':
            clip_R_jrc = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                'INPUT': str(QGIS_DIR + '/atagua_pp_r51_3763.tif'),
                'MASK': study_zone,
                'SOURCE_CRS': None,
                'TARGET_CRS': None, 'NODATA': None,
                'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                'OUTPUT': QgsProcessingUtils.generateTempFilename('clip_R_jrc.tif')})
            self.clip_R_JRC = clip_R_jrc['OUTPUT']
            units_R = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                           {'a': str(self.clip_R_JRC), 'b': None,
                            'c': None, 'd': None, 'e': None, 'f': None, 'expression': 'A*0.12*17.02',
                            'output': QgsProcessingUtils.generateTempFilename('units_R.tif'),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})
            self.units_R = units_R['output']

            #get extension
            gdal.AllRegister()

            gdalRaster = gdal.Open(str(self.units_R))

            x = gdalRaster.RasterXSize
            y = gdalRaster.RasterYSize
            geo = gdalRaster.GetGeoTransform()
            minx = geo[0]
            maxy = geo[3]
            maxx = minx + geo[1] * x
            miny = maxy + geo[5] * y
            extent_raster = str(minx) + "," + str(maxx) + "," + str(miny) + "," + str(maxy)

            #resample
            cellsize = selg.dlg.spinBox_3.value()
            Processing.runAlgorithm("grass7:r.resample", {'input': str(self.units_R),
                                                 'output': str(self.outputR),
                                                 'GRASS_REGION_PARAMETER': str(extent_raster) + '[EPSG:3763]',
                                                 'GRASS_REGION_CELLSIZE_PARAMETER': str(cellsize), 'GRASS_RASTER_FORMAT_OPT': '',
                                                 'GRASS_RASTER_FORMAT_META': ''})

        #JRC for R factor
        if self.method_R=='Joint Research Center':
            clip_R_jrc = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                'INPUT': str(QGIS_DIR + '/r_3763.tif'),
                'MASK': study_zone,
                'SOURCE_CRS': None,
                'TARGET_CRS': None, 'NODATA': None,
                'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                'OUTPUT': str(self.outputR)})



        # create K map
        if self.method_K.currentText()=='Pimenta, 1998':
            if self.checkBox.isChecked():
                inputLayer = self.dlg.comboBox_11.currentText()
                # layer information
                layer = QgsVectorLayer(inputLayer, 'inputLayer', "ogr")
                vectorlayer_vector = layer.dataProvider()
                # extent
                extent_rect = vectorlayer_vector.extent()
                xmin = extent_rect.xMinimum()
                xmax = extent_rect.xMaximum()
                ymin = extent_rect.yMinimum()
                ymax = extent_rect.yMaximum()
                extent = str(xmin) + "," + str(xmax) + "," + str(ymin) + "," + str(ymax)
                # attribute
                Elevation = self.dlg.comboBox_2.currentText()
                # cellsize
                cellSize = int(self.dlg.spinBox.value())
                outPath = self.dlg.lineEdit_10.text()
                # read fields and add a new column with the factor C
                fields = layer.fields()
                new_field = QgsField("Fator_K", QVariant.Double)
                layer_new = vectorlayer_vector.addAttributes([new_field])
                layer.updateFields()
                newFieldIndex = vectorlayer_vector.fieldNameIndex(new_field.name())
                allAttrs = vectorlayer_vector.attributeIndexes()
                # editing the new column
                numberRows = int(self.dlg.tableWidget.rowCount())
                numberColumns = int(self.dlg.tableWidget.columnCount())
                classes = ''
                lista = []
                for i in range(0, numberRows):
                    for j in range(0, numberColumns):
                        self.line = self.dlg.tableWidget.item(i, j)
                        lista = lista + [str(self.line.text())]

                        # list of description on tool table
                lista_table = lista

                field_names = [field.name() for field in fields]
                n = len(field_names)
                lista_attrib = []
                for i in range(0, n):
                    f = field_names[i]
                    if f == str(Elevation):
                        number = i
                        for feat in layer.getFeatures():
                            attrb = feat.attributes()
                            attribute_read = attrb[number]
                            lista_attrib = lista_attrib + [str(attribute_read)]
                # list of description on attribute table of shapefile
                lista_attributes = lista_attrib

                # permeability values list
                list_perm = []
                for i in range(0, numberRows):
                    self.perm = self.dlg.tableWidget.item(i, 1)
                    list_perm = list_perm + [str(self.perm.text())]

                # structure values list
                list_struct = []
                for i in range(0, numberRows):
                    self.struct = self.dlg.tableWidget.item(i, 2)
                    list_struct = list_struct + [str(self.struct.text())]

                    # clay percentage list
                list_clay = []
                for i in range(0, numberRows):
                    self.clay = self.dlg.tableWidget.item(i, 3)
                    list_clay = list_clay + [str(self.clay.text())]

                    # silt and very fine sand list
                list_silt = []
                for i in range(0, numberRows):
                    self.silt = self.dlg.tableWidget.item(i, 4)
                    list_silt = list_silt + [str(self.silt.text())]

                # gravel percentage list
                list_gravel = []
                for i in range(0, numberRows):
                    self.gravel = self.dlg.tableWidget.item(i, 5)
                    list_gravel = list_gravel + [str(self.gravel.text())]

                # MO percentage list
                list_org = []
                for i in range(0, numberRows):
                    self.org = self.dlg.tableWidget.item(i, 6)
                    list_org = list_org + [str(self.org.text())]

                len_items = len(list_org)

                # K factor, erodibility factor
                list_K_values = []
                for c in range(0, len_items):
                    # clay percentage calculated
                    clay = 100 - float(list_silt[c]) - float(list_gravel[c])

                    # particle size parameter
                    M = float(list_silt[c]) * (100 - clay)

                    # K fator SI
                    K = 27.66 * M**(1.14)*10 ** (-8) * (12 - float(list_org[c])) + 0.0043 * (
                                float(list_struct[c]) - 2) + 0.0033 * (float(list_perm[c]) - 3)

                    # K fator metrics (* 9.8 ms^2)
                    K_metrics = K * 9.8
                    list_K_values = list_K_values + [K_metrics]

                # without repetitions
                description_common = set(lista_attributes).intersection(lista_table)
                listDescription = list(description_common)

                # list of soil descriptions
                list_soil = []
                for i in range(0, numberRows):
                    self.soil = self.dlg.tableWidget.item(i, 0)
                    list_soil = list_soil + [str(self.soil.text())]

                    # assign the K values to each description in attribute table
                listElements = []
                listElem = []
                for j in range(0, len(listDescription)):
                    elem = lista_table.index(listDescription[j])
                    listElements = listElements + [elem]
                    elem_index = lista_table[int(elem + 1)]
                    listElem = listElem + [float(elem_index)]

                for l in range(0, len(listElem)):
                    layer.startEditing()
                    exp = QgsExpression(str(listElem[l]))
                    exp.prepare(fields)
                    elemDescription = lista_table[listElements[l]]
                    for f in layer.getFeatures():
                        # get attributes of column defined by the user
                        attrb_elem = f[number]
                        if attrb_elem == elemDescription:
                            f[newFieldIndex] = exp.evaluate(f)
                            layer.updateFeature(f)
                    layer.commitChanges()
                list_attrb_newField = []
                for features in layer.getFeatures():
                    attrb_newField = features.attributes()
                    attrb_newField_read = attrb_newField[number + 1]

                # update and read the new field
                fieldsNew = layer.fields()
                field_names_new = [newField.name() for newField in fieldsNew]
                parameter_indexes = field_names_new[newFieldIndex]

                Processing.initialize()
                # Processing.runAlgorithm("grass:v.to.rast.attribute", None, inputLayer, 0, parameter_indexes, extent, cellSize, -1.0, 0.0001, outPath)
                Processing.runAlgorithm("grass7:v.to.rast", {
                    'input': inputLayer,
                    'type': [0, 1, 3], 'where': '', 'use': 0, 'attribute_column': parameter_indexes, 'rgb_column': None,
                    'label_column': None, 'value': 1, 'memory': 300, 'output': outPath,
                    'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': cellSize,
                    'GRASS_RASTER_FORMAT_OPT': '',
                    'GRASS_RASTER_FORMAT_META': '', 'GRASS_SNAP_TOLERANCE_PARAMETER': -1,
                    'GRASS_MIN_AREA_PARAMETER': 0.0001})

            if self.checkBox2.isChecked():
                inputLayer = self.dlg.comboBox_11.currentText()
                # layer information
                layer = QgsVectorLayer(inputLayer, inputLayer, "ogr")
                vectorlayer_vector = layer.dataProvider()
                # extent
                extent_rect = vectorlayer_vector.extent()
                xmin = extent_rect.xMinimum()
                xmax = extent_rect.xMaximum()
                ymin = extent_rect.yMinimum()
                ymax = extent_rect.yMaximum()
                extent = str(xmin) + "," + str(xmax) + "," + str(ymin) + "," + str(ymax)
                # attribute
                Elevation = self.dlg.comboBox_2.currentText()
                # cellsize
                cellSize = int(self.dlg.spinBox.value())
                outPath = self.dlg.lineEdit_10.text()
                # read fields and add a new column with the factor C
                fields = layer.fields()
                new_field = QgsField("Fator_K", QVariant.Double)
                layer_new = vectorlayer_vector.addAttributes([new_field])
                layer.updateFields()
                newFieldIndex = vectorlayer_vector.fieldNameIndex(new_field.name())
                allAttrs = vectorlayer_vector.attributeIndexes()
                # editing the new column
                numberRows = int(self.dlg.tableWidget_2.rowCount())
                numberColumns = int(self.dlg.tableWidget_2.columnCount())
                classes = ''
                lista = []
                for i in range(0, numberRows):
                    for j in range(0, numberColumns):
                        self.line = self.dlg.tableWidget_2.item(i, j)
                        lista = lista + [str(self.line.text())]

                # list of description on tool table
                lista_table = lista

                field_names = [field.name() for field in fields]
                n = len(field_names)
                lista_attrib = []
                for i in range(0, n):
                    f = field_names[i]
                    if f == str(Elevation):
                        number = i
                        for feat in layer.getFeatures():
                            attrb = feat.attributes()
                            attribute_read = attrb[number]
                            lista_attrib = lista_attrib + [str(attribute_read)]
                # list of description on attribute table of shapefile
                lista_attributes = lista_attrib

                # without repetitions
                description_common = set(lista_attributes).intersection(lista_table)
                listDescription = list(description_common)

                # list of k values
                list_k = []
                for i in range(0, numberRows):
                    self.k = self.dlg.tableWidget_2.item(i, 1)
                    list_k = list_k + [str(self.k.text())]

                    # list of soil descriptions
                list_soil = []
                for i in range(0, numberRows):
                    self.soil = self.dlg.tableWidget_2.item(i, 0)
                    list_soil = list_soil + [str(self.soil.text())]

                    # assign the K values to each description in attribute table
                listElements = []
                for j in range(0, len(listDescription)):
                    elem = lista_table.index(listDescription[j])
                    listElements = listElements + [elem]

                for l in range(0, len(list_k)):
                    layer.startEditing()
                    exp = QgsExpression(str(list_k[l]))
                    # exp.prepare(fields)
                    elemDescription = list_soil[l]
                    for f in layer.getFeatures():
                        # get attributes of column defined by the user
                        attrb_elem = f[number]
                        if attrb_elem == elemDescription:
                            f[newFieldIndex] = exp.evaluate()
                            layer.updateFeature(f)
                    layer.commitChanges()
                list_attrb_newField = []
                for features in layer.getFeatures():
                    attrb_newField = features.attributes()
                    attrb_newField_read = attrb_newField[number + 1]

                # update and read the new field
                fieldsNew = layer.fields()
                field_names_new = [newField.name() for newField in fieldsNew]
                parameter_indexes = field_names_new[newFieldIndex]

                Processing.initialize()
                # Processing.runAlgorithm("grass7:v.to.rast.attribute", None, inputLayer, 0, parameter_indexes, extent, cellSize, -1.0, 0.0001, outPath)
                Processing.runAlgorithm("grass7:v.to.rast", {
                    'input': inputLayer,
                    'type': [0, 1, 3], 'where': '', 'use': 0, 'attribute_column': parameter_indexes, 'rgb_column': None,
                    'label_column': None, 'value': 1, 'memory': 300, 'output': str(self.outputK),
                    'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': cellSize,
                    'GRASS_RASTER_FORMAT_OPT': '',
                    'GRASS_RASTER_FORMAT_META': '', 'GRASS_SNAP_TOLERANCE_PARAMETER': -1,
                    'GRASS_MIN_AREA_PARAMETER': 0.0001})

        if self.method_K.currentText()=='Joint Research Center':
            clip_K_jrc = Processing.runAlgorithm("gdal:cliprasterbymasklayer", {
                'INPUT': str(QGIS_DIR + '/K_new_crop_3763.tif'),
                'MASK': study_zone,
                'SOURCE_CRS': None,
                'TARGET_CRS': None, 'NODATA': None,
                'ALPHA_BAND': False, 'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': False,
                'SET_RESOLUTION': False, 'X_RESOLUTION': None, 'Y_RESOLUTION': None,
                'MULTITHREADING': False, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '',
                'OUTPUT': str(self.outputK)})

        # create LS map
        if self.method_LS.currentText() == 'Wischmeier and Smith, 1978':
            #m_value
            m_value = Processing.runAlgorithm("native:reclassifybytable",
                           {'INPUT_RASTER': str(self.slope_perc),
                            'RASTER_BAND': 1, 'TABLE': [-100, 1, 0.2, 1, 3, 0.30, 3, 5, 0.40, 5, 10000, 0.54],
                            'NO_DATA': -9999, 'RANGE_BOUNDARIES': 1, 'NODATA_FOR_MISSING': False, 'DATA_TYPE': 5,
                            'OUTPUT': QgsProcessingUtils.generateTempFilename(
                                                         'm_value.tif')})
            self.mvalue = m_value['OUTPUT']
            #final formula
            LS_W = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                           {'a': str(self.slope_length),
                            'b': str(self.slope_degree),
                            'c': str(self.mvalue), 'd': None, 'e': None,
                            'f': None, 'expression': '((A/22.3)^C)*(65.41*(sin(B)^2) + 4.56*sin(B) + 0.065)',
                            'output': str(self.outputLS),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})


        if self.method_LS.currentText() == 'Mitasova, 1996':
            #final formula
            Processing.runAlgorithm("grass7:r.mapcalc.simple",
                           {'a': str(self.slopelength),
                            'b': str(self.slopedegree), 'c': None,
                            'd': None, 'e': None, 'f': None, 'expression': '((A/22.13)^0.6)*(sin(B)/0.0896)^1.6',
                            'output': str(self.outputLS),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})

        if self.method_LS.currentText() == 'Moore and Wilson, 1992':
            #flow_accum
            self.flow_accum = Processing.runAlgorithm("grass7:r.flow",
                           {'elevation': str(inputDEM_LS), 'aspect': None,
                            'barrier': None, 'skip': None, 'bound': None, '-u': False, '-3': False, '-m': False,
                            'flowline': 'TEMPORARY_OUTPUT', 'flowlength': 'TEMPORARY_OUTPUT',
                            'flowaccumulation': QgsProcessingUtils.generateTempFilename(
                                                         'flow_accum.tif'),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': '',
                            'GRASS_OUTPUT_TYPE_PARAMETER': 0, 'GRASS_VECTOR_DSCO': '', 'GRASS_VECTOR_LCO': '',
                            'GRASS_VECTOR_EXPORT_NOCAT': False})
            flow_accum = self.flow_accum['flowaccumulation']

            #final formula
            Processing.runAlgorithm("grass7:r.mapcalc.simple",
                           {'a': str(flow_accum),
                            'b': str(self.slopedegree), 'c': None,
                            'd': None, 'e': None, 'f': None, 'expression': '((A/22.13)^0.4)*((sin(B)/0.0896)^1.3)*1.4',
                            'output': str(self.outputLS),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})
        if self.method_LS.currentText() == 'McCool, 1987':
            #beta
            self.beta = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                           {'a': str(self.slopedegree), 'b': None,
                            'c': None, 'd': None, 'e': None, 'f': None,
                            'expression': '(sin(A)/0.0896)/(3.0*(sin(A)^0.8)+0.56)',
                            'output': QgsProcessingUtils.generateTempFilename(
                                                         'beta.tif'),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})
            beta=self.beta['output']
            #m
            self.m = Processing.runAlgorithm("grass7:r.mapcalc.simple",
                           {'a': str(beta), 'b': None, 'c': None,
                            'd': None, 'e': None, 'f': None, 'expression': 'A/(A+1)',
                            'output': QgsProcessingUtils.generateTempFilename(
                                                         'm.tif'),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})
            m = self.m['output']

            #final formula
            Processing.runAlgorithm("grass7:r.mapcalc.simple",
                           {'a': str(self.slopelength),
                            'b': str(m),
                            'c': str(self.slopedegree),
                            'd': str(slope_perc), 'e': None,
                            'f': None,
                            'expression': '(D>9)*(((A/22.13)^B)*10.8*sin(C)+0.03)+(D<=9)*(((A/22.13)^B)*16.8*sin(C)-0.5)',
                            'output': str(self.outputLS),
                            'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                            'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})


        #create P map
        if self.dlg.comboBox_5.currentText() != '':
            inputLayer_dem = self.dlg.comboBox_5.currentText()
            layer = QgsVectorLayer(inputLayer_dem, inputLayer_dem, "ogr")
            vectorlayer_vector = layer.dataProvider()
            # extent
            extent_rect = vectorlayer_vector.extent()
            xmin = extent_rect.xMinimum()
            xmax = extent_rect.xMaximum()
            ymin = extent_rect.yMinimum()
            ymax = extent_rect.yMaximum()
            extent = str(xmin) + "," + str(xmax) + "," + str(ymin) + "," + str(ymax)
            # attribute
            Elevation = self.dlg.comboBox_6.currentText()
            # cellsize
            cellSize = int(self.dlg.spinBox_2.value())
            outPath = self.dlg.lineEdit_2.text()
            # read fields and add a new column with the factor C
            fields = layer.fields()
            new_field = QgsField("Fator_C", QVariant.Double)
            layer_new = vectorlayer_vector.addAttributes([new_field])
            layer.updateFields()
            newFieldIndex = vectorlayer_vector.fieldNameIndex(new_field.name())
            allAttrs = vectorlayer_vector.attributeIndexes()
            # editing the new column
            numberRows = int(self.dlg.tableWidget_3.rowCount())
            numberColumns = int(self.dlg.tableWidget_3.columnCount())
            classes = ''
            lista = []
            for i in range(0, numberRows):
                for j in range(0, numberColumns):
                    self.line = self.dlg.tableWidget_3.item(i, j)
                    lista = lista + [str(self.line.text())]

            # list of description on tool table
            lista_table = lista

            field_names = [field.name() for field in fields]
            n = len(field_names)
            lista_attrib = []
            for i in range(0, n):
                f = field_names[i]
                if f == str(Elevation):
                    number = i
                    for feat in layer.getFeatures():
                        attrb = feat.attributes()
                        attribute_read = attrb[number]
                        lista_attrib = lista_attrib + [str(attribute_read)]
            # list of description on attribute table of shapefile
            lista_attributes = lista_attrib

            # obtain the indexes of the description of shapefile attribute table (nao repetidas)
            description_common = set(lista_attributes).intersection(lista_table)
            listDescription = list(description_common)

            listElem = []
            listElements = []
            for j in range(0, len(listDescription)):
                elem = lista_table.index(listDescription[j])
                listElements = listElements + [elem]

                elem_index = lista_table[int(elem + 1)]
                listElem = listElem + [float(elem_index)]

            for l in range(0, len(listElem)):
                layer.startEditing()
                exp = QgsExpression(str(listElem[l]))
                # exp.prepare(fields)
                elemDescription = lista_table[listElements[l]]
                # aguas interiores, culturas temporarias, ...
                for f in layer.getFeatures():
                    # get attributes of column defined by the user
                    attrb_elem = f[number]
                    if attrb_elem == elemDescription:
                        f[newFieldIndex] = exp.evaluate()
                        layer.updateFeature(f)
                layer.commitChanges()
            list_attrb_newField = []
            for features in layer.getFeatures():
                attrb_newField = features.attributes()
                attrb_newField_read = attrb_newField[number + 1]
                # novo atributo

            # update and read the new field
            fieldsNew = layer.fields()
            field_names_new = [newField.name() for newField in fieldsNew]
            parameter_indexes = field_names_new[newFieldIndex]

            Processing.initialize()
            # Processing.runAlgorithm("grass7:v.to.rast.attribute", None, inputLayer_dem, 0, parameter_indexes, extent, cellSize, -1.0, 0.0001, outPath)
            Processing.runAlgorithm("grass7:v.to.rast", {
                'input': inputLayer_dem,
                'type': [0, 1, 3], 'where': '', 'use': 0, 'attribute_column': parameter_indexes, 'rgb_column': None,
                'label_column': None, 'value': 1, 'memory': 300, 'output': str(self.outputP),
                'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': cellSize, 'GRASS_RASTER_FORMAT_OPT': '',
                'GRASS_RASTER_FORMAT_META': '', 'GRASS_SNAP_TOLERANCE_PARAMETER': -1,
                'GRASS_MIN_AREA_PARAMETER': 0.0001})

        # RUSLE calculation
        self.output_RUSLE = self.dlg.lineEdit_9.text()
        Processing.runAlgorithm("grass7:r.mapcalc.simple", {'a': str(self.outputK),
                                                   'b': str(self.outputR),
                                                   'c': str(self.outputLS),
                                                   'd': str(self.outputP), 'e': None, 'f': None, 'expression': 'A*B*C*D',
                                                   'output': str(self.output_RUSLE),
                                                   'GRASS_REGION_PARAMETER': None, 'GRASS_REGION_CELLSIZE_PARAMETER': 0,
                                                   'GRASS_RASTER_FORMAT_OPT': '', 'GRASS_RASTER_FORMAT_META': ''})




        # add result into canvas
        file_info_norm = QFileInfo(str(self.output_RUSLE))
        # QMessageBox.about(self, "teste", str(file_info_norm))
        rlayer_new_norm = QgsRasterLayer(self.output_RUSLE, file_info_norm.fileName(), 'gdal')
        # QMessageBox.about(self, "teste", str(rlayer_new_norm))
        QgsProject.instance().addMapLayer(rlayer_new_norm)
        self.dlg.widget.setExtent(rlayer_new_norm.extent())
        # set the map canvas layer set
        self.dlg.widget.setLayers([rlayer_new_norm])
